{"meta":{"title":"Richard","subtitle":"Java","description":"","author":"Richard","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"面试算法","slug":"面试算法","date":"2022-06-07T02:15:45.000Z","updated":"2022-06-07T02:16:38.988Z","comments":true,"path":"2022/06/07/面试算法/","link":"","permalink":"http://example.com/2022/06/07/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法高频面试 数组 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面1234567891011121314151617181920class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0; int j = nums.length - 1; while (i &lt;= j) &#123; if (nums[i]%2==1) &#123; i++; &#125; if (nums[j]%2==0) &#123; j--; &#125; if (i&lt;j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; &#125; return nums; &#125;&#125; 剑指 Offer 29. 顺时针打印矩阵12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[] spiralOrder(int[][] matrix) &#123; if (matrix.length==0 || matrix[0].length==0) return new int[]&#123;&#125;; int n = matrix.length; int m = matrix[0].length; int[] res = new int[n*m]; int left = 0; int right = m - 1; int top = 0; int bottom = n - 1; int k = 0; while (left&lt;=right &amp;&amp; top&lt;=bottom) &#123; for (int i=left; i&lt;=right; i++) &#123; res[k++] = matrix[top][i]; &#125; for (int i=top+1; i&lt;=bottom; i++) &#123; res[k++] = matrix[i][right]; &#125; if (left&lt;right &amp;&amp; top&lt;bottom) &#123; for (int i=right-1; i&gt;=left; i--) &#123; res[k++] = matrix[bottom][i]; &#125; for (int i=bottom-1; i&gt;top; i--) &#123; res[k++] = matrix[i][left]; &#125; &#125; left++; right--; top++; bottom--; &#125; return res; &#125;&#125; 31. 下一个排列1234567891011121314151617181920212223242526272829class Solution &#123; public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; while (i&gt;=0 &amp;&amp; nums[i]&gt;=nums[i+1]) &#123; i--; &#125; if (i&gt;=0) &#123; int j = nums.length - 1; while (j&gt;=0 &amp;&amp; nums[i]&gt;=nums[j]) &#123; j--; &#125; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; reverse(nums, i+1); &#125; public void reverse(int[] nums, int start) &#123; int l = start; int r = nums.length - 1; while (l&lt;r) &#123; int tmp = nums[l]; nums[l] = nums[r]; nums[r] = tmp; l++; r--; &#125; &#125;&#125; 88. 合并两个有序数组1234567891011121314151617class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int k = m + n - 1; int i = m - 1; int j = n - 1; while (k&gt;=0 &amp;&amp; i&gt;=0 &amp;&amp; j&gt;=0) &#123; if (nums1[i] &lt;= nums2[j]) &#123; nums1[k--] = nums2[j--]; &#125; else &#123; nums1[k--] = nums1[i--]; &#125; &#125; while (j&gt;=0) &#123; nums1[k--] = nums2[j--]; &#125; &#125;&#125; 41. 缺失的第一个正数12345678910111213141516171819202122232425class Solution &#123; public int firstMissingPositive(int[] nums) &#123; int n = nums.length; // 将负数变为n+1 for (int i=0; i&lt;n; i++) &#123; if (nums[i] &lt;= 0) &#123; nums[i] = n + 1; &#125; &#125; // 将&lt;=n 的元素对应位置变为负数 for (int i=0; i&lt;n; i++) &#123; int num = Math.abs(nums[i]); if (num &lt;= n) &#123; nums[num-1] = -Math.abs(nums[num-1]); &#125; &#125; // 返回第一个大于0的元素标加1 for (int i=0; i&lt;n; i++) &#123; if (nums[i] &gt; 0) &#123; return i + 1; &#125; &#125; return n + 1; &#125;&#125; 169. 多数元素123456789101112131415161718class Solution &#123; public int majorityElement(int[] nums) &#123; int r = 0; int c = 0; for (int x : nums) &#123; if (c == 0) &#123; r = x; &#125; if (r == x) &#123; c++; &#125; if (r != x) &#123; c--; &#125; &#125; return r; &#125;&#125; 240. 搜索二维矩阵 II123456789101112131415161718class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int n = matrix.length; int m = matrix[0].length; int i = 0; int j = m - 1; while (i&lt;n &amp;&amp; j&gt;=0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &lt; target) &#123; i++; &#125; else &#123; j--; &#125; &#125; return false; &#125;&#125; 链表 剑指 Offer 22. 链表中倒数第k个节点12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode f = head; ListNode s = head; while (k-- != 0) &#123; f = f.next; &#125; while (f!=null) &#123; s = s.next; f = f.next; &#125; return s; &#125;&#125; 剑指 Offer 25. 合并两个排序的链表1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode pre = new ListNode(0); ListNode cur = pre; while (l1!=null &amp;&amp; l2!=null) &#123; if (l1.val &lt;= l2.val) &#123; pre.next = l1; l1 = l1.next; &#125; else &#123; pre.next = l2; l2 = l2.next; &#125; pre = pre.next; &#125; pre.next = l1==null?l2:l1; return cur.next; &#125;&#125; 剑指 Offer 35. 复杂链表的复制12345678910111213141516171819202122232425262728293031/*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node cur = head; while (cur != null) &#123; map.put(cur, new Node(cur.val)); cur = cur.next; &#125; cur = head; while(cur!=null) &#123; map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; &#125; return map.get(head); &#125;&#125; 92. 反转链表 II123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode dum = new ListNode(0); dum.next = head; ListNode pre = dum; // 找到left的前一个 for (int i=0; i&lt;left-1; i++) &#123; pre = pre.next; &#125; // leftNode ListNode leftNode = pre.next; ListNode rightNode = pre; for (int i=0; i&lt;right-left+1; i++) &#123; rightNode = rightNode.next; &#125; // rightNode的下一个 ListNode curr = rightNode.next; // 切断 pre.next = null; rightNode.next = null; revrse(leftNode); // 连接 pre.next = rightNode; leftNode.next = curr; return dum.next; &#125; public ListNode revrse(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while (cur!=null) &#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 25. K 个一组翻转链表12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); ListNode dum = new ListNode(0); ListNode p = dum; while (true) &#123; int cnt = 0; ListNode tmp = head; while (cnt!=k &amp;&amp; tmp!=null) &#123; stack.push(tmp); tmp = tmp.next; cnt++; &#125; // 判断是否还有k个元素，没有那么直接返回就可以了 if (cnt!=k) &#123; p.next = head; break; &#125; // 有的话 while (!stack.isEmpty()) &#123; p.next = stack.pop(); p = p.next; &#125; // 指向 p.next = tmp; head = tmp; &#125; return dum.next; &#125;&#125; 234. 回文链表123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(null==head || null==head.next) return true; ListNode cur = head; ListNode right = head.next; while (cur.next!=null &amp;&amp; cur.next.next!=null) &#123; right = right.next; cur = cur.next.next; &#125; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while (right!=null) &#123; stack.push(right); right = right.next; &#125; while (!stack.isEmpty()) &#123; if (stack.pop().val!=head.val) &#123; return false; &#125; head = head.next; &#125; return true; &#125;&#125; 143. 重排链表1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); ListNode cur = head; while (cur!=null) &#123; list.add(cur); cur = cur.next; &#125; int i = 0; int j = list.size() - 1; while (i &lt; j) &#123; list.get(i).next = list.get(j); i++; if (i==j) &#123; break; &#125; list.get(j).next = list.get(i); j--; &#125; list.get(i).next = null; &#125;&#125; 160. 相交链表1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (null==headA || null==headB) return null; ListNode a = headA; ListNode b = headB; while (a!=b) &#123; a = a==null?headB:a.next; b = b==null?headA:b.next; &#125; return a; &#125;&#125; 23. 合并K个升序链表1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (null==lists || 0==lists.length) return null; ListNode dum = new ListNode(0); ListNode p = dum; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(lists.length, new Comparator&lt;&gt;()&#123; public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) &#123; queue.add(node); &#125; &#125; while (!queue.isEmpty()) &#123; p.next = queue.poll(); p = p.next; if (p.next != null) &#123; queue.add(p.next); &#125; &#125; return dum.next; &#125;&#125; 148. 排序链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if (null == head) return null; int n = 0; ListNode dum = new ListNode(0,head); ListNode node = head; while (node!=null) &#123; n++; node = node.next; &#125; for (int subLength=1; subLength&lt;n; subLength&lt;&lt;=1) &#123; ListNode pre = dum; ListNode cur = dum.next; while (cur!=null) &#123; // 第一个头 ListNode h1 = cur; for (int i=1; i&lt;subLength&amp;&amp;cur.next!=null; i++) &#123; cur = cur.next; &#125; // 第二个头 ListNode h2 = cur.next; // h1尾部断开 cur.next = null; cur = h2; for (int i=1; i&lt;subLength&amp;&amp;cur!=null&amp;&amp;cur.next!=null; i++) &#123; cur = cur.next; &#125; ListNode next = null; // 看是否cur为空，不为空需要断链 if (cur!=null) &#123; next = cur.next; cur.next = null; &#125; ListNode merged = merge(h1,h2); pre.next = merged; while (pre.next != null) &#123; pre = pre.next; &#125; // 同等级的下一个节点 cur = next; &#125; &#125; return dum.next; &#125; public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode l1 = h1; ListNode l2 = h2; ListNode dum = new ListNode(0); ListNode p = dum; while (l1!=null &amp;&amp; l2!=null) &#123; if (l1.val &lt;= l2.val) &#123; dum.next = l1; l1 = l1.next; &#125; else &#123; dum.next = l2; l2 = l2.next; &#125; dum = dum.next; &#125; dum.next = l1==null ? l2 : l1; return p.next; &#125;&#125; 2. 两数相加1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (null == l1) return l2; if (null == l2) return l1; int a = 0;// 进位 ListNode head = null; ListNode tail = null; while (l1!=null || l2!=null) &#123; int n1 = l1==null ? 0 : l1.val; int n2 = l2==null ? 0 : l2.val; int sum = n1 + n2 + a; a = sum/10; if (head == null) &#123; head = tail = new ListNode(sum%10); &#125; else &#123; tail.next = new ListNode(sum%10); tail = tail.next; &#125; if (l1!=null) &#123; l1 = l1.next; &#125; if (l2!=null) &#123; l2 = l2.next; &#125; &#125; if (a&gt;0) &#123; tail.next = new ListNode(1); &#125; return head; &#125;&#125; 19. 删除链表的倒数第 N 个结点123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode cur = head; while (cur!=null) &#123; cur = cur.next; n--; &#125; if (n==0) &#123; return head.next; &#125; if (n&lt;0) &#123; cur = head; while (++n != 0) &#123; cur = cur.next; &#125; cur.next = cur.next.next; &#125; return head; &#125;&#125; 24. 两两交换链表中的节点 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (null = head) return head; ListNode dum = new ListNode(0); dum.next = head; ListNode tmp = dum; while (tmp.next!=null &amp;&amp; tmp.next.next!=null) &#123; ListNode node1 = tmp.next; ListNode node2 = tmp.next.next; tmp.next = node2; node1.next = node2.next; node2.node2 = node1; tmp = node1; &#125; return dum.next; &#125;&#125; 141. 环形链表123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (null == head || null == head.next) return false; ListNode s = head; ListNode f = head.next; while (f!=null) &#123; s = s.next; f = f.next; if (f==null) &#123; return false; &#125; f = f.next; if (f == s) &#123; return true; &#125; &#125; return false; &#125;&#125; 142. 环形链表 II 123456789101112131415161718192021222324252627282930313233343536373839 慢指针指到b点的时候快指针在c&#x27;点a 是起点，b 是环的入口，c 是两个指针的第一次相遇点，ab 之间的距离是 x，bc 之间的距离是 y。则当first 走到 bb 时，由于 second 比 first 多走一倍的路，所以 second 已经从 bb 开始在环上走了 x 步，可能多余1圈，距离 b 还差 y 步（这是因为第一次相遇点在 b 之后 y 步，我们让 first 退回 b 点，则 second 会退 2y 步，也就是距离 b 点还差 y 步）；所以 second 从 b 点走 x+y 步即可回到 b 点，所以 second 从 c 点开始走，走 x 步即可恰好走到 b 点，同时让 first 从头开始走，走 x 步也恰好可以走到 b 点。所以第二次相遇点就是 b 点。/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (null==head || null==head.next) return null; ListNode s = head; ListNode f = head.next; while (f!=null) &#123; s = s.next; f = f.next; if (f==null) &#123; return null; &#125; f = f.next; if (f==s) &#123; s = head; f = f.next; while (f!=s) &#123; f = f.next; s = s.next; &#125; return f; &#125; &#125; return null; &#125;&#125; 328. 奇偶链表 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (null == head) return null; // 偶数链表的头节点 虚拟 ListNode eventHead = head.next; // 奇数链表 ListNode odd = head; // 实际操作 ListNode event = eventHead; // 跳出循环条件 偶数节点不为空或者偶数节点的写一个节点不为空 while (event!=null &amp;&amp; event.next!=null) &#123; // 奇数节点的写一个节点是偶数节点的下一个节点 odd.next = event.next; // 奇数节点后移 odd = odd.next; // 偶数节点的下一个是奇数节点的下一个 event.next = odd.next; // 偶数节点后移 event = event.next; &#125; // 连接奇偶链表 odd.next = eventHead; return head; &#125;&#125; 146. LRU 缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class LRUCache &#123; class Node&#123; int key; int value; Node pre; Node next; public Node()&#123;&#125; public Node(int key, int value) &#123; this.key = key; this.value = value; &#125; &#125; private Map&lt;Integer, Node&gt; cache = new HashMap&lt;&gt;(); private int size; private int capacity; private Node head, tail; public LRUCache(int capacity) &#123; this.size = 0; this.capacity = capacity; head = new Node(); tail = new Node(); head.next = tail; tail.pre = head; &#125; public int get(int key) &#123; Node node = cache.get(key); if (null == node) return -1; moveNode(node); return node.value; &#125; public void put(int key, int value) &#123; Node node = cache.get(key); if (null == node) &#123; Node newNode = new Node(key, value); cache.put(key, newNode); addHead(newNode); ++size; if (size &gt; capacity) &#123; Node tail = removeTail(); cache.remove(tail.key); --size; &#125; &#125; else &#123; node.value = value; moveNode(node); &#125; &#125; public void addHead(Node node) &#123; // node.next = head.next; // node.pre = head; // head.next.pre = node; // head.next = node; node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; &#125; public void removeNode(Node node) &#123; node.pre.next = node.next; node.next.pre = node.pre; &#125; public void moveNode(Node node) &#123; removeNode(node); addHead(node); &#125; public Node removeTail() &#123; Node res = tail.pre; removeNode(res); return res; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 树 144. 二叉树的前序遍历123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (null == root) return res; TreeNode node = root; while (!stack.isEmpty() || node!=null) &#123; while (node!=null) &#123; res.add(node.val); stack.push(node); node = node.left; &#125; node = stack.pop(); node = node.right; &#125; return res; &#125;&#125; 94. 二叉树的中序遍历123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (null == root) return res; TreeNode node = root; while (!stack.isEmpty() || node!=null) &#123; while (node!=null) &#123; stack.push(node); node = node.left; &#125; node = stack.pop(); res.add(node.val); node = node.right; &#125; return res; &#125;&#125; 145. 二叉树的后序遍历1234567891011121314151617181920212223242526272829303132333435右左根 反转为根左右/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (null == root) return res; TreeNode node = root; while (!stack.isEmpty() || node!=null) &#123; while (node!=null) &#123; res.add(node.val); stack.push(node); node = node.right; &#125; node = stack.pop(); node = node.left; &#125; Collections.reverse(res); return res; &#125;&#125; 102. 二叉树的层序遍历 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if (null == root) return res; q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (int i=0; i&lt;size; i++) &#123; TreeNode t = q.poll(); tmp.add(t.val); if (t.left!=null) q.offer(t.left); if (t.right!=null) q.offer(t.right); &#125; res.add(tmp); &#125; return res; &#125;&#125; 剑指 Offer 26. 树的子结构12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123; if (A==null || B==null) return false; return isSub(A,B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); &#125; public boolean isSub(TreeNode a, TreeNode b) &#123; if (b == null) &#123; return true; &#125; if (a == null) &#123; return false; &#125; if (a.val!=b.val) return false; return isSub(a.left,b.left) &amp;&amp; isSub(a.right, b.right); &#125;&#125; 剑指 Offer 27. 二叉树的镜像123456789101112131415161718192021222324252627和反转二叉树一个代码/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if (null == root) return null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode t = stack.pop(); // 先让右节点入栈 if (t.right!=null) stack.push(t.right); if (t.left!=null) stack.push(t.left); TreeNode tmp = t.left; t.left = t.right; t.right = tmp; &#125; return root; &#125;&#125; 剑指 Offer 28. 对称的二叉树1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (null == root) return true; return dfs(root, root); &#125; public boolean dfs(TreeNode A, TreeNode B) &#123; if (A==null || B==null) return A==null&amp;&amp;B==null; if (A.val !=B.val) return false; return dfs(A.right,B.left) &amp;&amp; dfs(A.left, B.right); &#125;&#125; 剑指 Offer 32 - I. 从上到下打印二叉树12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] levelOrder(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (null == root) return new int[]&#123;&#125;; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while (!q.isEmpty()) &#123; TreeNode t = q.poll(); res.add(t.val); if (null != t.left) q.offer(t.left); if (null != t.right) q.offer(t.right); &#125; int[] ans = new int[res.size()]; for (int i=0; i&lt;res.size(); i++) &#123; ans[i] = res.get(i); &#125; return ans; &#125;&#125; 剑指 Offer 32 - II. 从上到下打印二叉树 II1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if (null == root) return res; q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (int i=0; i&lt;size; i++) &#123; TreeNode t = q.poll(); tmp.add(t.val); if (t.left!=null) q.offer(t.left); if (t.right!=null) q.offer(t.right); &#125; res.add(tmp); &#125; return res; &#125;&#125; 剑指 Offer 32 - III. 从上到下打印二叉树 III12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if (null == root) return res; q.offer(root); boolean flag = false; while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (int i=0; i&lt;size; i++) &#123; TreeNode t = q.poll(); tmp.add(t.val); if (t.left!=null) q.offer(t.left); if (t.right!=null) q.offer(t.right); &#125; if (flag) &#123; Collections.reverse(tmp); &#125; flag = !flag; res.add(tmp); &#125; return res; &#125;&#125; 剑指 Offer 34. 二叉树中和为某一值的路径1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123; if (null == root) return res; dfs(root, target); return res; &#125; public void dfs(TreeNode root, int target) &#123; if (null == root) return ; target -= root.val; tmp.add(root.val); if (target==0 &amp;&amp; root.left==null &amp;&amp; root.right==null) &#123; res.add(new ArrayList&lt;&gt;(tmp)); &#125; dfs(root.left, target); dfs(root.right, target); tmp.remove(tmp.size()-1); &#125;&#125; 226. 翻转二叉树1234567891011121314151617181920212223242526和二叉树的镜像一个代码/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if (null == root) return null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode t = stack.pop(); if (t.right!=null) stack.push(t.right); if (t.left!=null) stack.push(t.left); TreeNode tmp = t.left; t.left = t.right; t.right = tmp; &#125; return root; &#125;&#125; 114. 二叉树展开为链表 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; // 先序遍历 List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while (node!=null || !stack.isEmpty()) &#123; while (node!=null) &#123; list.add(node); stack.push(node); node = node.left; &#125; node = stack.pop(); node = node.right; &#125; for (int i=1; i&lt;list.size(); i++) &#123; TreeNode pre = list.get(i-1); TreeNode cur = list.get(i); pre.left = null; pre.right = cur; &#125; &#125;&#125; 116. 填充每个节点的下一个右侧节点指针12345678910111213141516171819202122232425262728293031323334353637383940414243/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (null == root) return null; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); for (int i=0; i&lt;size; i++) &#123; Node node = q.poll(); // 最有一个不需要指 if (i &lt; size-1) &#123; node.next = q.peek(); &#125; if (node.left!=null) q.offer(node.left); if (node.right!=null) q.offer(node.right); &#125; &#125; return root; &#125;&#125; 654. 最大二叉树 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; return builderTree(nums, 0, nums.length); &#125; public TreeNode builderTree(int[] nums, int l, int r) &#123; if (l==r) return null; int max = maxIndex(nums, l, r); TreeNode root = new TreeNode(nums[max]); root.left = builderTree(nums, l, max); root.right = builderTree(nums, max+1, r); return root; &#125; public int maxIndex(int[] nums, int l, int r) &#123; int max = l; for (int i=l; i&lt;r; i++) &#123; if (nums[max] &lt; nums[i]) &#123; max = i; &#125; &#125; return max; &#125;&#125; 105. 从前序与中序遍历序列构造二叉树12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; for (int i=0; i&lt;inorder.length; i++) &#123; map.put(inorder[i], i); &#125; return builder(preorder, inorder, 0, 0, preorder.length-1); &#125; public TreeNode builder(int[] preorder, int[] inorder, int index, int l ,int r) &#123; if (l&gt;r) return null; int num = preorder[index]; int indexNum = map.get(num); int leftCnt = indexNum - l; TreeNode root = new TreeNode(num); root.left = builder(preorder, inorder, index+1, l, indexNum-1); root.right = builder(preorder, inorder, index+1+leftCnt, indexNum+1, r); return root; &#125;&#125; 106. 从中序与后序遍历序列构造二叉树 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) &#123; for (int i=0; i&lt;inorder.length; i++) &#123; map.put(inorder[i], i); &#125; return buildTree(postorder, inorder, 0, inorder.length-1, 0, inorder.length-1); &#125; // pr、pl表示当前子树后序遍历在数组中的位置 // il、ir表示当前子树中序遍历在数组中的位置 public TreeNode buildTree(int[] postorder, int[] inorder, int pl, int pr, int il, int ir) &#123; if (pl&gt;pr) return null; int val = postorder[pr]; int k = map.get(val) - il; TreeNode root = new TreeNode(val); root.left = buildTree(postorder, inorder, pl, pl+k-1, il, il+k-1); root.right = buildTree(postorder, inorder, pl+k, pr-1, il+k+1, ir); return root; &#125;&#125; 297. 二叉树的序列化与反序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (null == root) return &quot;#&quot;; StringBuilder sb = new StringBuilder(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode t = stack.pop(); if (null == t) &#123; sb.append(&quot;#&quot;).append(&quot;,&quot;); &#125; else &#123; sb.append(t.val).append(&quot;,&quot;); stack.push(t.right); stack.push(t.left); &#125; &#125; return sb.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Deque&lt;String&gt; q = new LinkedList&lt;&gt;(Arrays.asList(data.split(&quot;,&quot;))); return builderTree(q); &#125; public TreeNode builderTree(Deque&lt;String&gt; q) &#123; String s = q.poll(); if (&quot;#&quot;.equals(s)) &#123; return null; &#125; int val = Integer.parseInt(s); TreeNode root = new TreeNode(val); root.left = builderTree(q); root.right = builderTree(q); return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root)); 652. 寻找重复的子树1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;(); public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) &#123; dfs(root); return ans; &#125; String dfs(TreeNode node) &#123; if (node==null) return &quot;&quot;; String hashCode = node.val + &quot;[&quot; + dfs(node.left) + &quot;,&quot; + dfs(node.right); map.put(hashCode, map.getOrDefault(hashCode, 0) + 1); if (map.get(hashCode) == 2) &#123; ans.add(node); &#125; return hashCode; &#125;&#125; 103. 二叉树的锯齿形层序遍历1234567891011121314151617181920212223242526272829303132333435363738394041同从上到下遍历三/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); if (null == root) return res; q.offer(root); boolean flag = false; while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (int i=0; i&lt;size; i++) &#123; TreeNode t = q.poll(); tmp.add(t.val); if (t.left!=null) q.offer(t.left); if (t.right!=null) q.offer(t.right); &#125; if (flag) &#123; Collections.reverse(tmp); &#125; flag = !flag; res.add(tmp); &#125; return res; &#125;&#125; 剑指 Offer 33. 二叉搜索树的后序遍历序列12345678910111213141516171819202122232425262728293031323334 [ 左子树 | 右子树 | 根节点 ] 左&lt;根&lt;右 左&lt;右&gt;根 [1,3,2,6,5]// 递归分治class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; return isverifyPostorder(postorder, 0, postorder.length-1); &#125; public boolean isverifyPostorder(int[] q, int l, int r) &#123; if (l&gt;=r) return true; int mid = l; while (q[mid] &lt; q[r]) mid++; // 根节点最大 int root = mid; while (q[root] &gt; q[r]) root++; if (root!=r) return false; return isverifyPostorder(q, l, mid-1) &amp;&amp; isverifyPostorder(q,mid, r-1); &#125;&#125;// 单调栈[1,3,2,6,5] ---&gt; [5,6,2,3,1]class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for (int i=postorder.length-1; i&gt;=0; i--) &#123; if (postorder[i] &gt; root) return false; while (!stack.isEmpty() &amp;&amp; stack.peek()&gt;postorder[i]) &#123; root = stack.pop(); &#125; stack.push(postorder[i]); &#125; return true; &#125;&#125; 230. 二叉搜索树中第K小的元素12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (root!=null || !stack.isEmpty()) &#123; while (root!=null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); --k; if (0 == k) break; root = root.right; &#125; return root.val; &#125;&#125; 538. 把二叉搜索树转换为累加树123456789101112131415161718192021222324252627281038. 从二叉搜索树到更大和树/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int sum = 0; public TreeNode convertBST(TreeNode root) &#123; if (null != root) &#123; convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); &#125; return root; &#125;&#125; 450. 删除二叉搜索树中的节点1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (null == root) return null; if (key == root.val) &#123; if (root.left==null &amp;&amp; root.right==null) &#123; // 左右孩子都没有 return null; &#125; else if (root.left!=null &amp;&amp; root.right==null) &#123; // 有左孩子 return root.left; &#125; else if (root.left==null &amp;&amp; root.right!=null) &#123; // 有右孩子 return root.right; &#125; else if (root.left!=null &amp;&amp; root.right!=null) &#123; // 左右孩子都有 TreeNode node = root.right; // 后继 while (node.left!=null) &#123; node = node.left; &#125; // 替换 root.val = node.val; // 删除 root.right = deleteNode(root.right, node.val); &#125; &#125; else if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; return root; &#125;&#125; 701. 二叉搜索树中的插入操作 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (null == root) &#123; return new TreeNode(val); &#125; TreeNode pos = root; while (pos != null) &#123; if (val &lt; pos.val) &#123; if (pos.left == null) &#123; pos.left = new TreeNode(val); break; &#125; else &#123; pos = pos.left; &#125; &#125; else if (val &gt; pos.val) &#123; if (pos.right == null) &#123; pos.right = new TreeNode(val); break; &#125; else &#123; pos = pos.right; &#125; &#125; &#125; return root; &#125;&#125; 700. 二叉搜索树中的搜索1234567891011121314151617181920212223242526// 递归做法class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if (null == root) return null; if (root.val == val) &#123; return root; &#125; else if (root.val &lt; val)&#123; return searchBST(root.right, val); &#125; else if (root.val &gt; val) &#123; return searchBST(root.left, val); &#125; return root; &#125;&#125;// 迭代做法class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; while (root != null) &#123; if (val == root.val) &#123; return root; &#125; root = val &lt; root.val ? root.left : root.right; &#125; return null; &#125;&#125; 98. 验证二叉搜索树123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); double inorder = -Double.MAX_VALUE; // 中序遍历 while (!stack.isEmpty() || root!=null) &#123; while (root!=null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); // 违反中序递增 if (root.val &lt;= inorder) &#123; return false; &#125; inorder = root.val; root = root.right; &#125; return true; &#125;&#125; 96. 不同的二叉搜索树123456789101112131415class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for (int i=2; i&lt;=n; i++) &#123; // j是根节点 for (int j=1; j&lt;=i; j++) &#123; // 左面*右面 dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; 95. 不同的二叉搜索树 II12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (0 == n) &#123; return new LinkedList&lt;TreeNode&gt;(); &#125; return generateTrees(1, n); &#125; public List&lt;TreeNode&gt; generateTrees(int start, int end) &#123; List&lt;TreeNode&gt; allTrees = new LinkedList&lt;TreeNode&gt;(); if (start &gt; end) &#123; allTrees.add(null); return allTrees; &#125; for (int i=start; i&lt;=end; i++) &#123; List&lt;TreeNode&gt; leftTrees = generateTrees(start, i-1); List&lt;TreeNode&gt; rightTrees = generateTrees(i+1, end); for (TreeNode left : leftTrees) &#123; for (TreeNode right : rightTrees) &#123; TreeNode currTree = new TreeNode(i); currTree.left = left; currTree.right = right; allTrees.add(currTree); &#125; &#125; &#125; return allTrees; &#125; &#125; 1373. 二叉搜索子树的最大键值和12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int ans = 0; public int maxSumBST(TreeNode root) &#123; traverse(root); return ans; &#125; // 后序遍历二叉树，递归 // 返回以root为根的二叉树是否为二叉搜索树、最小节点、最大节点、节点之和 public int[] traverse(TreeNode root) &#123; if (null == root) &#123; return new int[] &#123;1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0&#125;; &#125; int[] leftTree = traverse(root.left); int[] rightTree = traverse(root.right); int[] res = new int[4]; // 判断以root为根节点的二叉树是否为二叉搜索树 if (leftTree[0]==1 &amp;&amp; rightTree[0]==1 &amp;&amp; root.val &gt; leftTree[2] &amp;&amp; root.val &lt; rightTree[1]) &#123; res[0] = 1; res[1] = Math.min(root.val, leftTree[1]); res[2] = Math.max(root.val, rightTree[2]); res[3] = root.val + leftTree[3] + rightTree[3]; ans = Math.max(res[3], ans); &#125; // 如果不是二叉搜索树， 直接返回res，默认初始化为[0,0,0,0]即可，因为用不到 return res; &#125;&#125; 662. 二叉树最大宽度 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; if (null == root) return 0; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); int res = 1; q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); res = Math.max(q.peekLast().val - q.peekFirst().val + 1, res); while (size-- &gt; 0) &#123; TreeNode cur = q.poll(); if (cur.left!=null) &#123; cur.left.val = cur.val*2 - 1; q.offer(cur.left); &#125; if (cur.right!=null) &#123; cur.right.val = cur.val*2; q.offer(cur.right); &#125; &#125; &#125; return res; &#125;&#125; 堆 剑指 Offer 41. 数据流中的中位数1234567891011121314151617181920212223242526272829class MedianFinder &#123; Queue&lt;Integer&gt; A, B; /** initialize your data structure here. */ public MedianFinder() &#123; A = new PriorityQueue&lt;&gt;(); // 小顶堆 保存较大的一半 B = new PriorityQueue&lt;&gt;((x,y) -&gt; (y-x)); // 大顶堆， 保存较小的一半 &#125; public void addNum(int num) &#123; if (A.size() != B.size()) &#123; A.add(num); B.add(A.poll()); &#125; else &#123; B.add(num); A.add(B.poll()); &#125; &#125; public double findMedian() &#123; return A.size()==B.size() ? (A.peek()+B.peek())/2.0 : A.peek(); &#125;&#125;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ 字符串 8. 字符串转换整数 (atoi)12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int myAtoi(String s) &#123; // 指针 int k = 0; // 消除空格 while (k&lt;s.length() &amp;&amp; s.charAt(k)==&#x27; &#x27;) &#123; k++; &#125; // 如果空格数等于s的长度，则s都为空格 if (k == s.length()) return 0; // 判断正负 int minus = 1; // 如果是负数，那么minus=-1 if (s.charAt(k) == &#x27;-&#x27;) &#123; minus = -1; k++; &#125; else if (s.charAt(k) == &#x27;+&#x27;) &#123; // 如果为负 k++; &#125; // 最终返回的 int res = 0; while (k&lt;s.length() &amp;&amp; s.charAt(k)&gt;=&#x27;0&#x27; &amp;&amp; s.charAt(k)&lt;=&#x27;9&#x27;) &#123; int x = s.charAt(k) - &#x27;0&#x27;; // 看有没有越界 if (res&gt;(Integer.MAX_VALUE-x)/10) &#123; return minus==-1 ? Integer.MIN_VALUE:Integer.MAX_VALUE; &#125; res = res*10 + x; k++; // 判断越界 if (res &gt; Integer.MAX_VALUE) &#123; break; &#125; &#125; res *= minus; if (res &gt; Integer.MAX_VALUE) res = Integer.MAX_VALUE; if (res &lt; Integer.MIN_VALUE) res = Integer.MIN_VALUE; return res; &#125;&#125; 151. 颠倒字符串中的单词1234567891011121314151617class Solution &#123; public String reverseWords(String s) &#123; int start, end; // 每个单词的开始和结束索引（左闭右开） StringBuilder sb = new StringBuilder(); for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s.charAt(i) == &#x27; &#x27;) continue; //跳过空格 end = i + 1; //找到结束索引 while (i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;) i--; //跳过空格 start = i + 1; //找到开始索引 for (int j = start; j &lt; end; j++) //将每个单词按开始结束索引赋值到StringBuilder sb.append(s.charAt(j)); sb.append(&#x27; &#x27;); //加上单词间的空格 &#125; sb.deleteCharAt(sb.length() - 1); //删掉最后一个多余的空格 return sb.toString(); &#125;&#125; 415. 字符串相加123456789101112131415161718class Solution &#123; public String addStrings(String num1, String num2) &#123; int i = num1.length() - 1; int j = num2.length() - 1; int add = 0; StringBuilder ans = new StringBuilder(); while (i&gt;=0 || j&gt;=0 || add!=0) &#123; int a = i&gt;=0? num1.charAt(i)-&#x27;0&#x27; : 0; int b = j&gt;=0? num2.charAt(j)-&#x27;0&#x27; : 0; int res = a + b + add; ans.append(res%10); add = res/10; i--; j--; &#125; return ans.reverse().toString(); &#125;&#125; 43. 字符串相乘123456789101112131415161718192021222324252627class Solution &#123; public String multiply(String num1, String num2) &#123; int n = num1.length(), m = num2.length(); int[] a = new int[n]; int[] b = new int[m]; for(int i = n-1; i &gt;= 0; i--) a[n-i-1] = num1.charAt(i) - &#x27;0&#x27;; for(int i = m-1; i &gt;= 0; i--) b[m-i-1] = num2.charAt(i) - &#x27;0&#x27;; int[] c = new int[n + m]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; c[i+j] += a[i] * b[j]; &#125; &#125; int carry = 0; for(int i = 0; i &lt; n + m - 1 || carry != 0; i++)&#123; int t = c[i] + carry; c[i] = t % 10; carry = t / 10; &#125; int k = n + m - 1; while(k &gt; 0 &amp;&amp; c[k] == 0) k--; StringBuilder res = new StringBuilder(); while(k &gt;= 0) res.append(c[k--]); return res.toString(); &#125;&#125; 栈与队列 剑指 Offer 09. 用两个栈实现队列12345678910111213141516171819202122232425262728class CQueue &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); public CQueue() &#123; &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (stack2.isEmpty()) return -1; return stack2.pop(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 剑指 Offer 31. 栈的压入、弹出序列12345678910111213141516171819202122class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int i = 0; int j = 0; while (i &lt; pushed.length) &#123; // 不同的时候入栈 if (pushed[i]!=popped[j]) &#123; stack.push(pushed[i++]); &#125; else &#123; // 相同的时候 i++; // 相当于跳过了4 j++; // 相当于跳过了相同的 // 比较是否相等 while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123; stack.pop(); j++; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 剑指 Offer 30. 包含min函数的栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 省空间 浪费时间class MinStack &#123; Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;(); /** initialize your data structure here. */ public MinStack() &#123; &#125; public void push(int x) &#123; stackData.push(x); if (stackMin.isEmpty()) &#123; stackMin.push(x); &#125; else if (x &lt;= stackMin.peek()) &#123; stackMin.push(x); &#125; &#125; public void pop() &#123; if (stackData.pop() == min()) &#123; stackMin.pop(); &#125; &#125; public int top() &#123; return stackData.peek(); &#125; public int min() &#123; return stackMin.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */// pop方便class MinStack &#123; Stack&lt;Integer&gt; stackMin = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stackData = new Stack&lt;&gt;(); /** initialize your data structure here. */ public MinStack() &#123; &#125; public void push(int x) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(x); &#125; else if (x &lt;= stackMin.peek()) &#123; stackMin.push(x); &#125; else &#123; int newMin = stackMin.peek(); stackMin.push(newMin); &#125; stackData.push(x); &#125; public void pop() &#123; stackData.pop(); stackMin.pop(); &#125; public int top() &#123; return stackData.peek(); &#125; public int min() &#123; return stackMin.peek(); &#125;&#125;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.min(); */ 剑指 Offer 59 - I. 滑动窗口的最大值12345678910111213141516171819202122232425class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int[] res = new int[nums.length-k+1]; if (nums.length == 0) return new int[]&#123;&#125;; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); int cnt = 0; // 下标 for (int i=0; i&lt;nums.length; i++) &#123; // 比较存进去的和i 存进去的比i小那么出 while (!qmax.isEmpty() &amp;&amp; nums[qmax.peekLast()] &lt;= nums[i]) &#123; qmax.pollLast(); &#125; // 存入当前 qmax.offerLast(i); // 判断边界 if (i-k == qmax.peekFirst()) &#123; qmax.pollFirst(); &#125; // 当窗口进去以后 if (i &gt;= k-1) &#123; res[cnt++] = nums[qmax.peekFirst()]; &#125; &#125; return res; &#125;&#125; 402. 移掉 K 位数字1234567891011121314151617181920class Solution &#123; public String removeKdigits(String num, int k) &#123; int n = num.length(); StringBuilder sb = new StringBuilder(); for (int i=0; i&lt;n; i++) &#123; // 只要遇到逆序就删除 while (k&gt;0 &amp;&amp; sb.length()&gt;0 &amp;&amp; num.charAt(i) &lt; sb.charAt(sb.length()-1)) &#123; sb.deleteCharAt(sb.length()-1); k--; &#125; // 如果刚开始就位0 那么直接下一次循环 if (sb.length()==0 &amp;&amp; num.charAt(i)==&#x27;0&#x27;) continue; // 每次都加进去 sb.append(num.charAt(i)); &#125; // 判断还有没有能删除的 如果有，直接删除最后的，因为前面的已经够小了 while (k--&gt;0 &amp;&amp; sb.length()&gt;0) sb.deleteCharAt(sb.length()-1); return sb.length()==0? &quot;0&quot; : sb.toString(); &#125;&#125; 224. 基本计算器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public int calculate(String s) &#123; // 存放所有的数字 Deque&lt;Integer&gt; nums = new ArrayDeque&lt;&gt;(); // 为了防止第一个数为负数，先往 nums 加个 0 nums.addLast(0); // 将所有的空格去掉 s = s.replaceAll(&quot; &quot;, &quot;&quot;); // 存放所有的操作，包括 +/- Deque&lt;Character&gt; ops = new ArrayDeque&lt;&gt;(); int n = s.length(); char[] cs = s.toCharArray(); for (int i=0; i&lt;n; i++) &#123; char c = cs[i]; if (c==&#x27;(&#x27;) &#123; ops.addLast(c); &#125; else if (c==&#x27;)&#x27;) &#123; while (!ops.isEmpty()) &#123; char op = ops.peekLast(); if (op!=&#x27;(&#x27;) &#123; calc(nums, ops); &#125; else &#123; ops.pollLast(); break; &#125; &#125; &#125; else &#123; if (isNum(c)) &#123; int x = 0; int j = i; while (j&lt;n &amp;&amp; isNum(cs[j])) &#123; x = x*10 + (cs[j++]-&#x27;0&#x27;); &#125; nums.addLast(x); i = j-1; &#125; else &#123; if (i&gt;0 &amp;&amp; (cs[i-1]==&#x27;(&#x27; || cs[i-1]==&#x27;+&#x27; || cs[i-1]==&#x27;-&#x27;)) &#123; nums.addLast(0); &#125; // 有一个新操作要入栈时，先把栈内可以算的都算了 while (!ops.isEmpty() &amp;&amp; ops.peekLast() != &#x27;(&#x27;) calc(nums, ops); ops.addLast(c); &#125; &#125; &#125; while (!ops.isEmpty()) calc(nums, ops); return nums.peekLast(); &#125; void calc(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops) &#123; if (nums.isEmpty() || nums.size() &lt; 2) return; if (ops.isEmpty()) return; int b = nums.pollLast(), a = nums.pollLast(); char op = ops.pollLast(); nums.addLast(op == &#x27;+&#x27; ? a + b : a - b); &#125; boolean isNum(char c) &#123; return Character.isDigit(c); &#125;&#125; 227. 基本计算器 II123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int calculate(String s) &#123; Stack&lt;Integer&gt; num = new Stack&lt;&gt;(); Stack&lt;Character&gt; op = new Stack&lt;&gt;(); Map&lt;Character,Integer&gt; pr = new HashMap&lt;&gt;(); pr.put(&#x27;+&#x27;,1); pr.put(&#x27;-&#x27;,1); pr.put(&#x27;*&#x27;,2); pr.put(&#x27;/&#x27;,2); char[] c = s.toCharArray(); for(int i = 0; i &lt; c.length; i++)&#123; if(c[i] == &#x27; &#x27;) continue; else if(Character.isDigit(c[i]))&#123; int x = 0, j = i; while(j &lt; c.length &amp;&amp; Character.isDigit(c[j]))&#123; x = x * 10 + c[j++] - &#x27;0&#x27;; &#125; i = j-1; num.push(x); &#125;else&#123; // 运算符 栈顶优先级大于 当前优先级 执行 while(op.size() != 0 &amp;&amp; pr.get(c[i]) &lt;= pr.get(op.peek())) eval(num,op); op.push(c[i]); &#125; &#125; while(op.size() != 0) eval(num,op); return num.peek(); &#125; void eval(Stack&lt;Integer&gt; num, Stack&lt;Character&gt; op)&#123; int b = num.pop(); int a = num.pop(); char c = op.pop(); if(c == &#x27;+&#x27;) a += b; else if (c == &#x27;-&#x27;) a -= b; else if (c == &#x27;*&#x27;) a *= b; else a /= b; num.push(a); &#125;&#125; 394. 字符串解码1234567891011121314151617181920212223242526dfsclass Solution &#123; int u; public String decodeString(String s) &#123; StringBuilder res = dfs(s); return res.toString(); &#125; public StringBuilder dfs(String s) &#123; StringBuilder sb = new StringBuilder(); while (u&lt;s.length() &amp;&amp; s.charAt(u)!=&#x27;]&#x27;) &#123; if (s.charAt(u)&gt;=&#x27;a&#x27;&amp;&amp;s.charAt(u)&lt;=&#x27;z&#x27; || s.charAt(u)&gt;=&#x27;A&#x27;&amp;&amp;s.charAt(u)&lt;=&#x27;Z&#x27;) &#123; sb.append(s.charAt(u++)); &#125; else &#123; int t = 0; while (s.charAt(u)!=&#x27;[&#x27;) t = t*10 + s.charAt(u++)-&#x27;0&#x27;; u++; // 过滤右括号 StringBuilder cur = dfs(s); for (int i=0; i&lt;t; i++) &#123; sb.append(cur); &#125; &#125; &#125; u++; return sb; &#125;&#125; 回溯 39. 组合总和12345678910111213141516171819202122232425// 每个数都可以使用无线次class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; dfs(candidates, 0, target); return res; &#125; public void dfs(int[] c, int u, int target) &#123; if (0 == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; // 找完了所有数 都没有凑出来target 说明无解 if (u == c.length) return; for (int i=0; c[u]*i&lt;=target; i++) &#123; dfs(c, u+1, target-c[u]*i); path.add(c[u]); &#125; // 回溯 for (int i=0; c[u]*i&lt;=target; i++) &#123; path.remove(path.size()-1); &#125; &#125;&#125; 40. 组合总和 II123456789101112131415161718192021222324252627282930313233// 每个数都可以使用1次class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); dfs(candidates, 0, target); return res; &#125; public void dfs(int[] c, int u, int target) &#123; if (0 == target) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; // 找完了所有数 都没有凑出来target 说明无解 if (u == c.length) return; // 这一段有多长 int k = u + 1; while (k&lt;c.length &amp;&amp; c[k] == c[u]) &#123; k++; &#125; // 个数 int cnt = k-u; for (int i=0; c[u]*i&lt;=target &amp;&amp; i&lt;=cnt; i++) &#123; dfs(c, k, target-c[u]*i); path.add(c[u]); &#125; // 恢复现场 for (int i=0; c[u]*i&lt;=target &amp;&amp; i&lt;=cnt; i++) &#123; path.remove(path.size()-1); &#125; &#125;&#125; 22. 括号生成12345678910111213141516171819202122// 合法：(&gt;) 或者相等class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; dfs(n, 0, 0, &quot;&quot;); return res; &#125; public void dfs(int n, int lc, int rc, String seq) &#123; if (lc==n &amp;&amp; rc==n) &#123; res.add(seq); &#125; else &#123; // 首先添加 左括号 if (lc &lt; n) &#123; dfs(n, lc+1, rc, seq+&#x27;(&#x27;); &#125; // 然后添加有括号 还必须判断此时左括号个数是否大于右括号 if (rc&lt;n &amp;&amp; lc&gt;rc) &#123; dfs(n, lc, rc+1, seq+&#x27;)&#x27;); &#125; &#125; &#125;&#125; 93. 复原 IP 地址123456789101112131415161718192021222324252627282930313233class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s.length() &gt; 12) return res; // 从第0开始搜，当先搜第0个数（总共有4个数） dfs(s, 0, 0, &quot;&quot;); return res; &#125; void dfs(String s, int u, int k, String path) &#123; if (u == s.length()) &#123; if (k == 4) &#123; path = path.substring(0, path.length()-1); res.add(path); return; &#125; &#125; // 不合法 以后搜了4个数了，还咩有结束，剪折 if(k == 4) return; //t当前数是多少 for (int i=u, t=0; i&lt;s.length(); i++) &#123; // 前导0 if (i&gt;u &amp;&amp; s.charAt(u)==&#x27;0&#x27;) &#123; break; &#125; t = t*10 + s.charAt(i)-&#x27;0&#x27;; if (t&lt;=255) &#123; dfs(s, i+1, k+1, path+t+&quot;.&quot;); &#125; else &#123; break; &#125; &#125; &#125;&#125; 78. 子集1234567891011121314151617181920212223242526272829303132333435// 迭代 2^n-1 0表示不选 1表示选class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int n = nums.length; for (int i=0; i&lt;(1&lt;&lt;n); i++) &#123; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); for (int j=0; j&lt;n; j++) &#123; if (((i&gt;&gt;j)&amp;1)!=0) &#123; path.add(nums[j]); &#125; &#125; res.add(new ArrayList&lt;&gt;(path)); &#125; return res; &#125;&#125;// dfs爆搜class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; dfs(0, nums); return res; &#125; public void dfs(int u, int[] nums) &#123; res.add(new ArrayList&lt;&gt;(path)); for (int i=u; i&lt;nums.length; i++) &#123; path.add(nums[i]); dfs(i+1, nums); path.remove(path.size()-1); &#125; &#125;&#125; 90. 子集 II12345678910111213141516171819202122232425262728class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); dfs(0, nums); return res; &#125; public void dfs(int u, int[] nums) &#123; if (u == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; // 重复 int k = u+1; while (k&lt;nums.length &amp;&amp; nums[k] == nums[u]) &#123; k++; &#125; for (int i=0; i&lt;=k-u; i++) &#123; dfs(k,nums); path.add(nums[u]); &#125; // 恢复现场 for (int i=0; i&lt;=k-u; i++) &#123; path.remove(path.size()-1); &#125; &#125;&#125; 剑指 Offer 12. 矩阵中的路径123456789101112131415161718192021222324252627282930313233343536//同 单词搜索// dfsclass Solution &#123; public boolean exist(char[][] board, String word) &#123; for (int i=0; i&lt;board.length; i++) &#123; for (int j=0; j&lt;board[0].length; j++) &#123; if (dfs(board, word, 0, i, j)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean dfs(char[][] board, String word, int u, int x, int y) &#123; if (x&lt;0 || x&gt;board.length || y&lt;0 || y&gt;board[0].length || board[x][y]!=word.charAt(u)) &#123; return false; &#125; if (u == word.length()-1) return true; int[] dx = &#123;0,0,1,-1&#125;; int[] dy = &#123;1,-1,0,0&#125;; char c = board[x][y]; board[x][y] = &#x27;*&#x27;; for (int i=0; i&lt;4; i++) &#123; int a = x + dx[i]; int b = y + dy[i]; if (a&gt;=0 &amp;&amp; a&lt;board.length &amp;&amp; b&gt;=0 &amp;&amp; b&lt;board[0].length &amp;&amp; board[a][b]!=&#x27;*&#x27;) &#123; if (dfs(board,word,u+1, a, b))&#123; return true; &#125; &#125; &#125; // 恢复现场 board[x][y] = c; return false; &#125;&#125; 剑指 Offer 13. 机器人的运动范围123456789101112131415161718192021222324252627282930313233343536373839// bfsclass Solution &#123; boolean[][] st = new boolean[105][105]; public int movingCount(int m, int n, int k) &#123; int res = 0; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]&#123;0,0&#125;); st[0][0] = true; while (!q.isEmpty()) &#123; int[] cc = q.poll(); int x = cc[0]; int y = cc[1]; if (getTwoSum(x,y) &gt; k) continue; res++; int[] dx = &#123;0,0,1,-1&#125;; int[] dy = &#123;1,-1,0,0&#125;; for (int i=0; i&lt;4; i++) &#123; int a = x + dx[i]; int b = y + dy[i]; if (a&gt;=0 &amp;&amp; a&lt;m &amp;&amp; b&gt;=0 &amp;&amp;b&lt;n &amp;&amp;st[a][b]==false &amp;&amp; getTwoSum(a,b)&lt;=k) &#123; q.offer(new int[]&#123;a,b&#125;); st[a][b] = true; &#125; &#125; &#125; return res; &#125; int getSum(int x) &#123; int res = 0; while (x!=0) &#123; res += x%10; x /= 10; &#125; return res; &#125; int getTwoSum(int x, int y) &#123; return getSum(x)+getSum(y); &#125;&#125; 113. 路径总和 II12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; dfs(root, targetSum); return res; &#125; public void dfs(TreeNode root, int targetSum) &#123; if (null == root) return; path.add(root.val); if (targetSum == root.val &amp;&amp; root.left==null &amp;&amp; root.right==null) &#123; res.add(new ArrayList&lt;&gt;(path)); &#125; dfs(root.left, targetSum-root.val); dfs(root.right, targetSum-root.val); // 回溯 path.remove(path.size()-1); &#125;&#125; 46. 全排列12345678910111213141516171819202122class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; dfs(nums, 0); return res; &#125; public void dfs(int[] nums, int u) &#123; if (u == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i&lt;nums.length; i++) &#123; if (path.contains(nums[i])) &#123; continue; &#125; path.add(nums[i]); dfs(nums, u+1); path.remove(path.size()-1); &#125; &#125;&#125; 47. 全排列 II1234567891011121314151617181920212223242526272829class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); // 是否被使用 boolean[] st; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; st = new boolean[nums.length]; Arrays.sort(nums); dfs(0, nums); return res; &#125; public void dfs(int u, int[] nums) &#123; if (u == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i=0; i&lt;nums.length; i++) &#123; //相同直接下一个。并且被使用过 if (st[i] || (i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !st[i-1])) &#123; continue; &#125; path.add(nums[i]); st[i] = true; dfs(u+1, nums); st[i] = false; path.remove(u); &#125; &#125;&#125; 剑指 Offer 38. 字符串的排列123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); char[] c; public String[] permutation(String s) &#123; c = s.toCharArray(); dfs(0); return res.toArray(new String[0]); &#125; public void dfs(int u) &#123; if (u == c.length) &#123; res.add(String.valueOf(c)); return; &#125; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i=u; i&lt;c.length; i++) &#123; if (set.contains(c[i])) &#123; continue; &#125; set.add(c[i]); swap(i,u); dfs(u+1); swap(i,u); &#125; &#125; public void swap(int a, int b) &#123; char tmp = c[a]; c[a] = c[b]; c[b] = tmp; &#125;&#125; 贪心和动态规划 剑指 Offer 14- I. 剪绳子剑指 Offer 14- II. 剪绳子 II12345678910111213141516// 12都用这个就可以// 3*3&gt;2*2//尽可能将绳子以长度 3 等分为多段时，乘积最大。class Solution &#123; public int cuttingRope(int n) &#123; if (n == 2) return 1; if (n == 3) return 2; long res = 1; while (n &gt; 4) &#123; res *= 3; res %= 1000000007; n -= 3; &#125; return (int)(res*n%1000000007); &#125;&#125; 322. 零钱兑换1234567891011121314151617// 完全背包一维class Solution &#123; // m 背包容量 public int coinChange(int[] coins, int m) &#123; int n = coins.length; int[] dp = new int[m+1]; Arrays.fill(dp, m+1); dp[0] = 0; for (int v : coins) &#123; for (int j=v; j&lt;=m; j++) &#123; dp[j] = Math.min(dp[j], dp[j-v]+1); &#125; &#125; if (dp[m] == m+1) return -1; return dp[m]; &#125;&#125; 剑指 Offer 42. 连续子数组的最大和1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int s = 0; int res = Integer.MIN_VALUE; for (int x : nums) &#123; if (s&lt;0) &#123; s = 0; &#125; s += x; res = Math.max(res, s); &#125; return res; &#125;&#125; 剑指 Offer 43. 1～n 整数中 1 出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; public int countDigitOne(int n) &#123; return hasOne(n); &#125; public int hasOne(int n) &#123; if (0 == n) return 0; String num = String.valueOf(n); // 最高位 int high = num.charAt(0) - &#x27;0&#x27;; // 有几位 100 int pow = (int) (Math.pow(10, num.length()-1)); // 比如123 left即使23 int left = n - high * pow; // high是否为1 if (1 == high) &#123; // hasOne(left)下一次循环 + left+1(1~23) + hasOne(pow-1)100的1已经加上了 所以是pow-1 return hasOne(left) + left+1 + hasOne(pow-1); &#125; else &#123; // high大于1 hasOne(left)下一次 + hasOne(pow-1)*high 有几个 + pow0~99个1 return hasOne(left) + hasOne(pow-1)*high + pow; &#125; &#125;&#125;// 贪心class Solution &#123; public int countDigitOne(int n) &#123; int digit = 1, res = 0; int high = n / 10, cur = n % 10, low = 0; while(high != 0 || cur != 0) &#123; if(cur == 0) res += high * digit; else if(cur == 1) res += high * digit + low + 1; else res += (high + 1) * digit; low += cur * digit; cur = high % 10; high /= 10; digit *= 10; &#125; return res; &#125;&#125;///case 1: cur=0 2 3 0 4 千位和百位可以选00 01 02....22 十位可以取到1( 形如[00|01..|22]1[0-9] 都是&lt;2304 ) 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,如果十位取1 那就是形如 231[0-9] &gt; 2304,所以当千位和百位取23，十位只能能取0，个位取0-4即 2300 2301 2302 2303 2304 但是2301不应该算进来，这个1是 单独 出现在个位的（而11，121,111这种可以被算多次） 即 23*10case 2: cur=1 2 3 1 4 千位和百位可以选00 01 02....22 十位可以取到1 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,十位取1，个位可以去0-4 即 2310-2314共5个 即 23 *10 + 4 +1case 3: cur&gt;1 即2-9 2 3 2 4 千位和百位可以选00 01 02....22 十位可以取到1(形如 [00|01...|22]1[0-9] 都是&lt;2324) 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,十位取1，个位可以去0-9 即 2310-2319共10个 （其中2311，被计算了两次，分别是从个位和十位分析得到的1次） 即 23 *10 + 10 剑指 Offer 45. 把数组排成最小的数 123456789101112131415class Solution &#123; public String minNumber(int[] nums) &#123; String[] strs = new String[nums.length]; for (int i=0; i&lt;nums.length; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; // 排序如上 Arrays.sort(strs, (x,y) -&gt; (x+ y).compareTo(y+x)); StringBuilder res = new StringBuilder(); for (String s : strs) &#123; res.append(s); &#125; return res.toString(); &#125;&#125; 剑指 Offer 46. 把数字翻译成字符串123456789101112131415161718class Solution &#123; public int translateNum(int num) &#123; String strs = String.valueOf(num); int[] dp = new int[strs.length()]; if (strs.length() == 0) return 0; if (strs.length() &lt; 2) return 1; dp[0] = 1; dp[1] = (strs.charAt(0)==&#x27;1&#x27; || strs.charAt(0)==&#x27;2&#x27; &amp;&amp; strs.charAt(1)&gt;=&#x27;0&#x27; &amp;&amp; strs.charAt(1)&lt;=&#x27;5&#x27;) ? 2 : 1; for (int i=2; i&lt;strs.length(); i++) &#123; if (strs.charAt(i-1)==&#x27;1&#x27; || strs.charAt(i-1)==&#x27;2&#x27; &amp;&amp; strs.charAt(i)&gt;=&#x27;0&#x27; &amp;&amp; strs.charAt(i)&lt;=&#x27;5&#x27;) &#123; dp[i] = dp[i-1] + dp[i-2]; &#125; else &#123; dp[i] = dp[i-1]; &#125; &#125; return dp[strs.length()-1]; &#125;&#125; 剑指 Offer 49. 丑数123456789101112131415161718192021class Solution &#123; public int nthUglyNumber(int n) &#123; if (0 == n) return 0; int a = 0; int b = 0; int c = 0; int[] dp = new int[n]; dp[0] = 1; for (int i=1; i&lt;n; i++) &#123; int n1 = dp[a] * 2; int n2 = dp[b] * 3; int n3 = dp[c] * 5; int min = Math.min(n1, Math.min(n2, n3)); dp[i] = min; if (min == n1) a++; if (min == n2) b++; if (min == n3) c++; &#125; return dp[n-1]; &#125;&#125; 剑指 Offer 60. n个骰子的点数12345678910111213141516class Solution &#123; public double[] dicesProbability(int n) &#123; double[] dp = new double[6]; Arrays.fill(dp, 1.0/6.0); for (int i=2; i&lt;=n; i++) &#123; double[] tmp = new double[i*5+1]; for (int j=0; j&lt;dp.length; j++) &#123; for (int k=0; k&lt;6; k++) &#123; tmp[j+k] += dp[j]/6.0; &#125; &#125; dp = tmp; &#125; return dp; &#125;&#125; 剑指 Offer 61. 扑克牌中的顺子123456789101112class Solution &#123; public boolean isStraight(int[] nums) &#123; if (0 == nums.length) return false; Arrays.sort(nums); int idx = 0; while (0 == nums[idx]) idx++; for (int i=idx; i&lt;nums.length-1; i++) &#123; if (nums[i] == nums[i+1]) return false; &#125; return nums[nums.length-1]-nums[idx] &lt;= 4; &#125;&#125; 剑指 Offer 62. 圆圈中最后剩下的数字123456789// 约瑟夫问题、枪毙问题class Solution &#123; public int lastRemaining(int n, int m) &#123; if (0 == n) return 0; // 每次n少一个 然后m不变，重新+m从下一个开始重新开始数 // (新编号+m)%n return (lastRemaining(n-1, m)+m)%n; &#125;&#125; 300. 最长递增子序列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (0 == nums.length) return 0; int[] dp = new int[nums.length]; dp[0] = 1; int res = 1; for (int i=1; i&lt;nums.length; i++) &#123; dp[i] = 1; for (int j=0; j&lt;i; j++) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = Math.max(dp[i], dp[j]+1); &#125; &#125; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125;class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; int[] q = new int[n+1]; int len = 0; for (int x : nums) &#123; int l = 0; int r = len; while (l&lt;r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; x) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; len = Math.max(len,r+1); q[r+1] = x; &#125; return len; &#125;&#125;/** * 896. 最长上升子序列 II */public class Main &#123; static int n; static final int N = 100010; // 每个数 static int[] a = new int[N]; // 所有不同长度下上升子序列的最小值 static int[] q = new int[N]; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); String[] cur = br.readLine().split(&quot; &quot;); for (int i=1; i&lt;=n; i++) &#123; a[i] = Integer.parseInt(cur[i-1]); &#125; int len = 0; q[0] = (int)-2e9; for (int i=1; i&lt;=n; i++) &#123; int l = 0; int r = len; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; // r找的是可以接到哪个数的后面 len = Math.max(len, r+1); q[r+1] = a[i]; &#125; System.out.println(len); &#125;&#125; 32. 最长有效括号1234567891011121314151617181920212223class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = 0; for (int i=0,start=-1; i&lt;s.length(); i++) &#123; if (s.charAt(i) == &#x27;(&#x27;) &#123; stack.push(i); &#125; else &#123; if (!stack.isEmpty()) &#123; stack.pop(); if (!stack.isEmpty()) &#123; res = Math.max(res, i-stack.peek()); &#125; else &#123; // 栈为空 长度就是从起点开始 res = Math.max(res, i-start); &#125; &#125; else &#123; // 重新下一次 start = i; &#125; &#125; &#125; return res; &#125;&#125; 221. 最大正方形1234567891011121314151617class Solution &#123; public int maximalSquare(char[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m+1][n+1]; int res = 0; for (int i=1; i&lt;=m; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; if (matrix[i-1][j-1] == &#x27;1&#x27;) &#123; dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j],dp[i][j-1]))+1; res = Math.max(res, dp[i][j]); &#125; &#125; &#125; return res*res; &#125;&#125;","categories":[],"tags":[{"name":"剑指offer、HOT100、面试高频","slug":"剑指offer、HOT100、面试高频","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer%E3%80%81HOT100%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"}]},{"title":"Hexo使用","slug":"Hexo","date":"2022-06-06T14:09:06.000Z","updated":"2022-06-07T00:02:46.737Z","comments":true,"path":"2022/06/06/Hexo/","link":"","permalink":"http://example.com/2022/06/06/Hexo/","excerpt":"","text":"安装node和npm省略node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry&#x3D;http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址 创建博客hexo n “我的第一篇文章” #创建新的文章返回blog目录hexo clean #清理hexo g #生成 远程部署Github创建一个新的仓库 lyj344272564.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.yml 123456 # Deployment ## Docs: https://hexo.io/docs/deployment.html​ deploy: type: git repo: https://github.com/lyj344272564/lyj344272564.github.io.git branch: master hexo d #部署到Github仓库里https://lyj344272564.github.io/ #访问这个地址可以查看博客 切换主题 git clone https://github.com/litten/hexo-theme-yilia.git themes&#x2F;yilia #下载yilia主题到本地 #修改hexo根目录下的 _config.yml 文件 ： theme: yilia hexo c #清理一下hexo g #生成hexo d #部署到远程Github仓库https://lyj344272564.github.io/ #查看博客","categories":[],"tags":[{"name":"Hexo使用","slug":"Hexo使用","permalink":"http://example.com/tags/Hexo%E4%BD%BF%E7%94%A8/"}]}],"categories":[],"tags":[{"name":"剑指offer、HOT100、面试高频","slug":"剑指offer、HOT100、面试高频","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer%E3%80%81HOT100%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"},{"name":"Hexo使用","slug":"Hexo使用","permalink":"http://example.com/tags/Hexo%E4%BD%BF%E7%94%A8/"}]}